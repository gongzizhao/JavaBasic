### 单例模式

单例模式保证了 系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能。
当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使用new

单例模式使用的场景：需要频繁的进行创建和销毁的对象、创建对象时耗时过多或耗费资源过多(即：重量级对象)，但又经常用到的对象、工具类对象、频繁访问数据库或文件的对象(比如数据源、session工厂等)

### 工厂模式

三种工厂模式 (简单工厂模式、工厂方法模式、抽象工厂模式)

意义：将实例化对象的代码提取出来，放到一个类中统一管理和维护，达到和主项目的依赖关系的解耦。从而提高项目的扩展和维护性。

设计模式的依赖抽象原则

创建对象实例时，不要直接 new 类, 而是把这个new 类的动作放在一个工厂的方法中，并返回。

变量不要直接持有具体类的引用。
不要让类继承具体类，而是继承抽象类或者是实现interface(接口)
不要覆盖基类中已经实现的方法。

简单工厂，就是一个工厂里面可以加工一个类型的不同实例对象，比如可以加工好座椅，也可以加工坏座椅，但必须是座椅。

工厂方法的一个工厂只能加工一个类型的一个实例对象。比如，座椅，一个工厂只能加工一种质量的座椅出来。

抽象工厂比较适合一个产品簇。因为一个工厂可以加工多个不同类型的实例对象。比如【座椅，轮胎】，一个工厂不但可以加工出来座椅，还可以加工出来轮胎，但是座椅，和轮胎的种类只能是一种。

### 原型模式

1)创建新的对象比较复杂时，可以利用原型模式简化对象的创建过程，同时也能够提高效率

2)不用重新初始化对象，而是动态地获得对象运行时的状态

3)如果原始对象发生变化(增加或者减少属性)，其它克隆对象的也会发生相应的变化，无需修改代码

4)在实现深克隆的时候可能需要比较复杂的代码

5)**缺点**：需要为每一个类配备一个克隆方法，这对全新的类来说不是很难，但对已有的类进行改造时，需要修改其源代码，违背了ocp原则，这点请同学们注意.

### 适配器模式

1)三种命名方式，是根据 src是以怎样的形式给到Adapter（在Adapter里的形式）来命名的。 

- **类适配器：以类给到，在Adapter里，就是将src当做类，继承** 

1. Java是单继承机制，所以类适配器需要继承src类这一点算是一个缺点, 因为这要求dst必须是接口，有一定局限性;
2. src类的方法在Adapter中都会暴露出来，也增加了使用的成本。
3. 由于其继承了src类，所以它可以根据需求重写src类的方法，使得Adapter的灵活性增强了。

-  **对象适配器：以对象给到，在Adapter里，将src作为一个对象，持有**

1. 根据合成复用原则，使用组合替代继承， 所以它解决了类适配器必须继承src的局限性问题，也不再要求dst必须是接口。
2. 使用成本更低，更灵活。

-  **接口适配器：以接口给到，在Adapter里，将src作为一个接口，实现**

1. 一些书籍称为：适配器模式(Default Adapter Pattern)或缺省适配器模式。 
2. 当不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，并为该接口中每个方法提供一个默认实现（空方法），那么该抽象类的子类可有选择地覆盖父类的某些方法来实现需求
3. 适用于一个接口不想使用其所有的方法的情况。

3)Adapter模式最大的作用还是将原本不兼容的接口融合在一起工作。 

4)实际开发中，实现起来不拘泥于我们讲解的三种经典形式 

桥接模式

